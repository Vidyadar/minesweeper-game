<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper - Farcaster Game</title>
    
    <!-- Essential Open Graph Meta Tags (Primary for embeds) -->
    <meta property="og:title" content="💣 Minesweeper Game" />
    <meta property="og:description" content="Can you clear the minefield? 3 difficulty levels, beat the clock, mobile-friendly!" />
    <meta property="og:image" content="https://minesweeper-game-pearl.vercel.app/assets/preview.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:url" content="https://minesweeper-game-pearl.vercel.app/" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Minesweeper Game" />
    
    <!-- Farcaster Frame Meta Tags -->
<meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://minesweeper-game-pearl.vercel.app/assets/preview.png","button":{"title":"Play","action":{"type":"launch_frame","name":"Minesweeper","url":"https://minesweeper-game-pearl.vercel.app/","splashImageUrl":"https://minesweeper-game-pearl.vercel.app/assets/splash.png","splashBackgroundColor":"#667eea"}}}' />

    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="💣 Minesweeper Game" />
    <meta name="twitter:description" content="Can you clear the minefield? Play Minesweeper on Farcaster!" />
    <meta name="twitter:image" content="https://minesweeper-game-pearl.vercel.app/assets/preview.png" />
    
    <!-- Additional Meta Tags -->
    <meta name="description" content="Play Minesweeper on Farcaster! Mobile-friendly game with 3 difficulty levels. Share your results and challenge friends." />
    <meta name="keywords" content="minesweeper, farcaster, game, puzzle, mobile, web3, nft, base" />
    <meta name="author" content="vidhyadar.base.eth" />
    
    <!-- Web3 Libraries -->
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <script src="https://unpkg.com/@wagmi/core@1.4.7/dist/wagmi-core.umd.js"></script>
    <script src="https://unpkg.com/@wagmi/connectors@1.1.1/dist/wagmi-connectors.umd.js"></script>
    
    <!-- Farcaster SDK -->
    <script type="module">
      import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk'
      window.farcasterSdk = sdk;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 400px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 0.9rem;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2rem;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .difficulty-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .difficulty-btn {
            padding: 8px 12px;
            font-size: 0.8rem;
            min-width: 60px;
        }

        .difficulty-btn.active {
            background: rgba(255, 255, 255, 0.4);
            font-weight: bold;
        }

        /* Enhanced mode toggle button styling */
        #toggle-mode {
            position: relative;
            overflow: hidden;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #toggle-mode.dig-mode {
            background: rgba(76, 175, 80, 0.8);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
        }

        #toggle-mode.flag-mode {
            background: rgba(244, 67, 54, 0.8);
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.3);
        }

        #toggle-mode:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .minefield {
            display: grid;
            gap: 2px;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto;
            max-width: 100%;
            overflow: auto;
        }

        .cell {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        .cell.revealed {
            background: rgba(255, 255, 255, 0.6);
            cursor: default;
        }

        .cell.revealed:hover {
            transform: none;
        }

        .cell.flagged {
            background: rgba(255, 100, 100, 0.8);
            color: white;
        }

        .cell.mine {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            animation: explode 0.5s ease-out;
        }

        .cell.false-flag {
            background: rgba(255, 69, 0, 0.9);
            color: white;
            animation: shake 0.5s ease-out;
        }

        @keyframes explode {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        .cell.number-1 { color: #0066cc; }
        .cell.number-2 { color: #009900; }
        .cell.number-3 { color: #ff0000; }
        .cell.number-4 { color: #000080; }
        .cell.number-5 { color: #800000; }
        .cell.number-6 { color: #008080; }
        .cell.number-7 { color: #000000; }
        .cell.number-8 { color: #808080; }

        .game-message {
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .game-message.win {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }

        .game-message.lose {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6666;
        }

        .instructions {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.8rem;
            text-align: center;
            line-height: 1.4;
        }

        .share-section {
            margin-top: 15px;
            text-align: center;
        }

        .share-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .share-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(138, 43, 226, 0.8);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .share-btn:hover {
            background: rgba(138, 43, 226, 1);
            transform: translateY(-2px);
        }

        .share-btn.warpcast {
            background: rgba(139, 69, 255, 0.8);
        }

        .share-btn.warpcast:hover {
            background: rgba(139, 69, 255, 1);
        }

        .share-result {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 8px;
            color: #00ff88;
            font-size: 0.9rem;
            border: 1px solid rgba(0, 255, 0, 0.3);
            display: none;
        }

        /* Sound toggle button */
        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        /* Web3 Wallet and NFT Styles */
        .web3-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            text-align: center;
        }
        
        .wallet-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #8a2be2 0%, #4b0082 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            width: 100%;
            max-width: 250px;
        }
        
        .wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .wallet-btn:disabled {
            background: rgba(128, 128, 128, 0.5);
            cursor: not-allowed;
        }
        
        .wallet-status {
            font-size: 0.9rem;
            margin: 10px 0;
            color: #00ff88;
        }
        
        .nft-info {
            margin: 15px 0;
            font-size: 0.9rem;
        }
        
        .nft-progress {
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .nft-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #4b0082);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .mint-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #00c853 0%, #009624 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
            width: 100%;
            max-width: 250px;
        }
        
        .mint-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .mint-btn:disabled {
            background: rgba(128, 128, 128, 0.5);
            cursor: not-allowed;
        }
        
        .transaction-status {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #00ff88;
            min-height: 20px;
        }
        
        .hidden {
            display: none;
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 15px;
                margin: 10px;
            }
            
            .game-title {
                font-size: 1.5rem;
            }
            
            .cell {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }
            
            .difficulty-buttons {
                flex-wrap: wrap;
            }
            
            .btn {
                font-size: 0.8rem;
                padding: 8px 15px;
            }

            .sound-toggle {
                top: 10px;
                right: 10px;
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            .wallet-btn, .mint-btn {
                font-size: 0.8rem;
                padding: 8px 15px;
            }
        }
        </style>
       

</head>
<body>
    <!-- Sound toggle button -->
    <button class="sound-toggle" id="sound-toggle">🔊</button>

    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">💣 Minesweeper</h1>
        </div>
        
        <div class="difficulty-buttons">
            <button class="btn difficulty-btn active" data-difficulty="easy">Easy</button>
            <button class="btn difficulty-btn" data-difficulty="medium">Medium</button>
            <button class="btn difficulty-btn" data-difficulty="hard">Hard</button>
        </div>

        <div class="game-stats">
            <div class="stat">
                <span>Mines</span>
                <span class="stat-value" id="mines-count">10</span>
            </div>
            <div class="stat">
                <span>Flags</span>
                <span class="stat-value" id="flags-count">0</span>
            </div>
            <div class="stat">
                <span>Time</span>
                <span class="stat-value" id="timer">0</span>
            </div>
        </div>

        <div class="game-controls">
            <button class="btn" id="new-game">New Game</button>
            <button class="btn dig-mode" id="toggle-mode">👆 Reveal Mode</button>
        </div>

        <div class="minefield" id="minefield"></div>
        
        <div class="game-message" id="game-message"></div>
        
        <div class="share-section">
            <div class="share-result" id="share-result">Link copied to clipboard! 📋</div>
            <div class="share-buttons">
                <button class="share-btn" id="share-warpcast">
                    🟣 Share on Warpcast
                </button>
                <button class="share-btn" id="share-general">
                    🔗 Copy Game Link
                </button>
                <button class="share-btn" id="share-result-btn" style="display: none;">
                    🏆 Share Result
                </button>
            </div>
        </div>
        
        <div class="instructions">
            <strong>How to play:</strong><br>
            • Tap to reveal cells<br>
            • Use Flag Mode to mark mines<br>
            • Numbers show nearby mines<br>
            • Find all mines to win!
        </div>
        
        <!-- Web3 Wallet and NFT Section -->
        <div class="web3-container">
            <h3 style="margin-bottom: 15px;">🎮 Minesweeper NFT Collection</h3>
            <p class="nft-info">Connect your wallet to mint a limited edition Minesweeper NFT on Base chain.<br>Only 2,500 NFTs available!</p>
            
            <div class="nft-progress">
                <div class="nft-progress-bar" id="nft-progress-bar"></div>
            </div>
            <p class="nft-info"><span id="nft-minted-count">0</span>/2500 NFTs minted</p>
            
            <button class="wallet-btn" id="connect-wallet">Connect Wallet</button>
            <p class="wallet-status" id="wallet-status"></p>
            
            <button class="mint-btn hidden" id="mint-nft" disabled>Mint NFT (Free + Gas)</button>
            <p class="transaction-status" id="transaction-status"></p>
            <p class="transaction-status" id="mint-info" aria-live="polite"></p>
        </div>
    </div>

    <script>
        class Minesweeper {
            constructor() {
                this.gameState = 'ready'; // ready, playing, won, lost
                this.flagMode = false;
                this.firstClick = true;
                this.timer = 0;
                this.timerInterval = null;
                this.soundEnabled = true;
                
                this.difficulties = {
                    easy: { rows: 9, cols: 9, mines: 10 },
                    medium: { rows: 12, cols: 12, mines: 20 },
                    hard: { rows: 15, cols: 15, mines: 35 }
                };
                
                this.currentDifficulty = 'easy';
                this.config = this.difficulties.easy;
                
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                
                this.createSounds();
                this.initializeGame();
                this.setupEventListeners();
            }
            
            createSounds() {
                // Create audio context for sound effects
                this.audioContext = null;
                this.audioInitialized = false;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            initializeAudio() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                this.audioInitialized = true;
            }
            
            playSound(type) {
                if (!this.soundEnabled || !this.audioContext) return;
                
                // Initialize audio on first interaction
                if (!this.audioInitialized) {
                    this.initializeAudio();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                switch (type) {
                    case 'click':
                        oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;
                    case 'flag':
                        oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.15);
                        break;
                    case 'mine':
                        // Enhanced explosion sound - more dramatic
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(30, this.audioContext.currentTime + 0.8);
                        gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.8);
                        console.log('Playing mine explosion sound!'); // Debug log
                        break;
                    case 'win':
                        // Victory sound - ascending notes
                        const notes = [523, 659, 784, 1047]; // C, E, G, C
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                const osc = this.audioContext.createOscillator();
                                const gain = this.audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(this.audioContext.destination);
                                osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                                gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                                osc.start();
                                osc.stop(this.audioContext.currentTime + 0.3);
                            }, i * 150);
                        });
                        return; // Skip the default oscillator code
                }
            }
            
            initializeGame() {
                this.gameState = 'ready';
                this.firstClick = true;
                this.timer = 0;
                this.clearTimer();
                
                const { rows, cols, mines } = this.config;
                
                // Initialize arrays
                this.board = Array(rows).fill().map(() => Array(cols).fill(0));
                this.revealed = Array(rows).fill().map(() => Array(cols).fill(false));
                this.flagged = Array(rows).fill().map(() => Array(cols).fill(false));
                
                this.updateStats();
                this.createMinefield();
                this.clearMessage();
                
                // Hide share result button on new game
                document.getElementById('share-result-btn').style.display = 'none';
                
                // Reset mode to dig mode
                this.flagMode = false;
                this.updateModeButton();
            }
            
            setupEventListeners() {
                document.getElementById('new-game').addEventListener('click', () => this.initializeGame());
                document.getElementById('toggle-mode').addEventListener('click', () => this.toggleMode());
                
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.changeDifficulty(e.target.dataset.difficulty));
                });

                // Sound toggle
                document.getElementById('sound-toggle').addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    document.getElementById('sound-toggle').textContent = this.soundEnabled ? '🔊' : '🔇';
                });

                // Share functionality
                document.getElementById('share-warpcast').addEventListener('click', () => this.shareToWarpcast());
                document.getElementById('share-general').addEventListener('click', () => this.copyGameLink());
                document.getElementById('share-result-btn').addEventListener('click', () => this.shareResult());
            }
            
            changeDifficulty(difficulty) {
                this.currentDifficulty = difficulty;
                this.config = this.difficulties[difficulty];
                
                document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-difficulty="${difficulty}"]`).classList.add('active');
                
                this.initializeGame();
            }
            
            toggleMode() {
                this.flagMode = !this.flagMode;
                this.updateModeButton();
                this.playSound('flag'); // Play sound when switching modes
            }
            
            updateModeButton() {
                const btn = document.getElementById('toggle-mode');
                if (this.flagMode) {
                    btn.textContent = '🚩 Flag Mode';
                    btn.className = 'btn flag-mode';
                } else {
                    btn.textContent = '👆 Reveal Mode';
                    btn.className = 'btn dig-mode';
                }
            }
            
            createMinefield() {
                const minefield = document.getElementById('minefield');
                const { rows, cols } = this.config;
                
                minefield.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                minefield.innerHTML = '';
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const cell = document.createElement('button');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Handle both click and touch events
                        cell.addEventListener('click', (e) => this.handleCellClick(e));
                        cell.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            this.handleRightClick(row, col);
                        });
                        
                        minefield.appendChild(cell);
                    }
                }
            }
            
            placeMines(excludeRow, excludeCol) {
                const { rows, cols, mines } = this.config;
                let minesPlaced = 0;
                
                while (minesPlaced < mines) {
                    const row = Math.floor(Math.random() * rows);
                    const col = Math.floor(Math.random() * cols);
                    
                    // Don't place mine on first click or if already has mine
                    if ((row === excludeRow && col === excludeCol) || this.board[row][col] === -1) {
                        continue;
                    }
                    
                    this.board[row][col] = -1;
                    minesPlaced++;
                    
                    // Update adjacent numbers
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            
                            if (this.isValidCell(newRow, newCol) && this.board[newRow][newCol] !== -1) {
                                this.board[newRow][newCol]++;
                            }
                        }
                    }
                }
            }
            
            isValidCell(row, col) {
                return row >= 0 && row < this.config.rows && col >= 0 && col < this.config.cols;
            }
            
            handleCellClick(e) {
                if (this.gameState === 'won' || this.gameState === 'lost') return;
                
                // Initialize audio on first user interaction
                if (!this.audioInitialized) {
                    this.initializeAudio();
                }
                
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                if (this.flagMode) {
                    this.handleRightClick(row, col);
                } else {
                    this.revealCell(row, col);
                }
            }
            
            handleRightClick(row, col) {
                if (this.revealed[row][col]) return;
                
                this.flagged[row][col] = !this.flagged[row][col];
                this.playSound('flag'); // Play flag sound
                this.updateCellDisplay(row, col);
                this.updateStats();
            }
            
            revealCell(row, col) {
                if (this.revealed[row][col] || this.flagged[row][col]) return;
                
                if (this.firstClick) {
                    this.placeMines(row, col);
                    this.firstClick = false;
                    this.gameState = 'playing';
                    this.startTimer();
                }
                
                this.revealed[row][col] = true;
                
                if (this.board[row][col] === -1) {
                    // Play explosion sound immediately when mine is hit
                    console.log('Mine hit! Playing explosion sound...');
                    this.playSound('mine');
                    this.updateCellDisplay(row, col);
                    // Small delay to let the explosion sound start before game over
                    setTimeout(() => {
                        this.gameOver(false);
                    }, 100);
                    return;
                }
                
                this.playSound('click'); // Play click sound only for safe cells
                
                if (this.board[row][col] === 0) {
                    // Reveal adjacent cells for empty cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (this.isValidCell(newRow, newCol)) {
                                this.revealCell(newRow, newCol);
                            }
                        }
                    }
                }
                
                this.updateCellDisplay(row, col);
                this.checkWinCondition();
            }
            
            updateCellDisplay(row, col) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                
                // Clear all special classes first
                cell.classList.remove('flagged', 'mine', 'false-flag');
                
                if (this.flagged[row][col]) {
                    cell.textContent = '🚩';
                    cell.classList.add('flagged');
                } else {
                    if (this.revealed[row][col]) {
                        cell.classList.add('revealed');
                        
                        if (this.board[row][col] === -1) {
                            cell.textContent = '💣';
                            cell.classList.add('mine');
                        } else if (this.board[row][col] > 0) {
                            cell.textContent = this.board[row][col];
                            cell.classList.add(`number-${this.board[row][col]}`);
                        } else {
                            cell.textContent = '';
                        }
                    } else {
                        cell.textContent = '';
                        cell.classList.remove('revealed');
                    }
                }
            }
            
            checkWinCondition() {
                const { rows, cols } = this.config;
                let cellsToReveal = 0;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (this.board[row][col] !== -1 && !this.revealed[row][col]) {
                            cellsToReveal++;
                        }
                    }
                }
                
                if (cellsToReveal === 0) {
                    this.gameOver(true);
                }
            }
            
            gameOver(won) {
                this.gameState = won ? 'won' : 'lost';
                this.clearTimer();
                
                if (won) {
                    this.playSound('win');
                } else {
                    // Mine sound is already played in revealCell, so just reveal mines and false flags
                    console.log('Game over - revealing all mines and false flags');
                    this.revealMinesAndFalseFlags();
                }
                
                this.showMessage(won);
                
                // Show share result button if game is completed
                const shareResultBtn = document.getElementById('share-result-btn');
                shareResultBtn.style.display = 'inline-flex';
            }
            
            revealMinesAndFalseFlags() {
                for (let row = 0; row < this.config.rows; row++) {
                    for (let col = 0; col < this.config.cols; col++) {
                        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        
                        if (this.board[row][col] === -1) {
                            // Reveal mine
                            this.revealed[row][col] = true;
                            this.updateCellDisplay(row, col);
                        } else if (this.flagged[row][col]) {
                            // This is a false flag
                            cell.classList.add('false-flag');
                            cell.textContent = '❌';
                        }
                    }
                }
            }
            
            showMessage(won) {
                const messageEl = document.getElementById('game-message');
                if (won) {
                    messageEl.textContent = `🎉 You Won in ${this.timer}s!`;
                    messageEl.className = 'game-message win';
                } else {
                    messageEl.textContent = '💥 Game Over!';
                    messageEl.className = 'game-message lose';
                }
            }
            
            clearMessage() {
                const messageEl = document.getElementById('game-message');
                messageEl.textContent = '';
                messageEl.className = 'game-message';
            }
            
            updateStats() {
                const flagsUsed = this.flagged.flat().filter(f => f).length;
                document.getElementById('mines-count').textContent = this.config.mines;
                document.getElementById('flags-count').textContent = flagsUsed;
                document.getElementById('timer').textContent = this.timer;
            }
            
            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    this.updateStats();
                }, 1000);
            }
            
            clearTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            // Farcaster sharing methods
            getGameUrl() {
                // Get current page URL or use a default
                return window.location.href || 'https://your-domain.com/minesweeper.html';
            }

            getDifficultyEmoji() {
                switch(this.currentDifficulty) {
                    case 'easy': return '🟢';
                    case 'medium': return '🟡';
                    case 'hard': return '🔴';
                    default: return '💣';
                }
            }

            generateResultText() {
                const difficultyEmoji = this.getDifficultyEmoji();
                const difficultyName = this.currentDifficulty.charAt(0).toUpperCase() + this.currentDifficulty.slice(1);
                const { rows, cols, mines } = this.config;
                
                if (this.gameState === 'won') {
                    return `🎉 I just won Minesweeper! ${difficultyEmoji}\n\n` +
                           `Difficulty: ${difficultyName} (${rows}×${cols}, ${mines} mines)\n` +
                           `Time: ${this.timer}s ⏱️\n\n` +
                           `Think you can beat my time? 🤔\n` +
                           `Play here: ${this.getGameUrl()}`;
                } else {
                    return `💥 I got blown up in Minesweeper! ${difficultyEmoji}\n\n` +
                           `Difficulty: ${difficultyName} (${rows}×${cols}, ${mines} mines)\n` +
                           `Time survived: ${this.timer}s ⏱️\n\n` +
                           `Think you can do better? 💪\n` +
                           `Try your luck: ${this.getGameUrl()}`;
                }
            }

            shareToWarpcast() {
                const gameUrl = this.getGameUrl();
                const shareText = `🎮 Playing Minesweeper on Farcaster! 💣\n\nCan you clear the minefield without exploding? 🤔\n\n🎯 3 difficulty levels\n⏱️ Beat the clock\n📱 Mobile-friendly\n\nPlay now: ${gameUrl}`;
                
                // Encode the text for URL
                const encodedText = encodeURIComponent(shareText);
                
                // Warpcast share URL
                const warpcastUrl = `https://warpcast.com/~/compose?text=${encodedText}`;
                
                // Open in new window/tab
                window.open(warpcastUrl, '_blank', 'width=600,height=400');
            }

            async copyGameLink() {
                const gameUrl = this.getGameUrl();
                
                try {
                    await navigator.clipboard.writeText(gameUrl);
                    this.showShareResult('Game link copied to clipboard! 🔗');
                } catch (err) {
                    // Fallback for browsers that don't support clipboard API
                    this.fallbackCopyTextToClipboard(gameUrl);
                }
            }

            shareResult() {
                if (this.gameState === 'ready' || this.gameState === 'playing') {
                    this.showShareResult('Finish the game first! 🎮', 'error');
                    return;
                }

                const resultText = this.generateResultText();
                const encodedText = encodeURIComponent(resultText);
                const warpcastUrl = `https://warpcast.com/~/compose?text=${encodedText}`;
                
                window.open(warpcastUrl, '_blank', 'width=600,height=400');
            }

            fallbackCopyTextToClipboard(text) {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                
                // Avoid scrolling to bottom
                textArea.style.top = "0";
                textArea.style.left = "0";
                textArea.style.position = "fixed";
                
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        this.showShareResult('Game link copied to clipboard! 🔗');
                    } else {
                        this.showShareResult('Could not copy link 😅', 'error');
                    }
                } catch (err) {
                    this.showShareResult('Could not copy link 😅', 'error');
                }
                
                document.body.removeChild(textArea);
            }

            showShareResult(message, type = 'success') {
                const shareResult = document.getElementById('share-result');
                shareResult.textContent = message;
                shareResult.style.display = 'block';
                
                if (type === 'error') {
                    shareResult.style.background = 'rgba(255, 0, 0, 0.1)';
                    shareResult.style.color = '#ff6666';
                    shareResult.style.borderColor = 'rgba(255, 0, 0, 0.3)';
                } else {
                    shareResult.style.background = 'rgba(0, 255, 0, 0.1)';
                    shareResult.style.color = '#00ff88';
                    shareResult.style.borderColor = 'rgba(0, 255, 0, 0.3)';
                }
                
                // Hide after 3 seconds
                setTimeout(() => {
                    shareResult.style.display = 'none';
                }, 3000);
            }
        }
        
        // Web3 Wallet and NFT Functionality
        class MinesweeperNFT {
            constructor() {
                this.provider = null;
                this.signer = null;
                this.address = null;
                this.isConnected = false;
                this.chainId = 8453; // Base chain ID
                this.nftContract = null;
                this.nftContractAddress = "0xDeD9E2Ba6f705aFb182b0d2568aE3468636aCA1b";
                this.mintPrice = ethers.utils.parseEther("0");
                this.maxSupply = 2500;
                this.currentSupply = 0;
                
                this.connectButton = document.getElementById('connect-wallet');
                this.walletStatus = document.getElementById('wallet-status');
                this.mintButton = document.getElementById('mint-nft');
                this.transactionStatus = document.getElementById('transaction-status');
                this.nftProgressBar = document.getElementById('nft-progress-bar');
                this.nftMintedCount = document.getElementById('nft-minted-count');
                this.mintInfo = document.getElementById('mint-info');
                this.mintSection = document.querySelector('.web3-container');
                
                this.setupEventListeners();
                this.checkWalletConnection();
                this.showMintInfo("Connect your wallet on Base to mint the Early Access NFT");
            }
            
            setupEventListeners() {
                this.connectButton.addEventListener('click', () => this.connectWallet());
                this.mintButton.addEventListener('click', () => this.mintNFT());
            }
            
            async checkWalletConnection() {
                // Check if MetaMask is installed
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        // Check if already connected
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (accounts.length > 0) {
                            this.handleAccountsChanged(accounts);
                            await this.checkAndSwitchChain();
                        } else {
                            this.showMintInfo("Connect your wallet on Base to mint the Early Access NFT");
                            await this.ensureContractInitialized();
                        }
                        
                        window.ethereum.removeAllListeners('accountsChanged');
                        window.ethereum.on('accountsChanged', (accounts) => this.handleAccountsChanged(accounts));
                        window.ethereum.removeAllListeners('chainChanged');
                        window.ethereum.on('chainChanged', () => this.handleChainChanged());
                    } catch (error) {
                        console.error("Error checking wallet connection:", error);
                        this.showMintInfo("Wallet connection check failed");
                    }
                } else {
                    this.walletStatus.textContent = "Please install MetaMask to connect";
                }
            }
            
            async connectWallet() {
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        this.walletStatus.textContent = "Connecting...";
                        
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        this.handleAccountsChanged(accounts);
                        await this.checkAndSwitchChain();
                    } catch (error) {
                        console.error("Error connecting wallet:", error);
                        this.walletStatus.textContent = "Connection failed. Please try again.";
                    }
                } else {
                    this.walletStatus.textContent = "Please install MetaMask to connect";
                    window.open('https://metamask.io/download.html', '_blank');
                }
            }
            
            async handleChainChanged() {
                this.walletStatus.textContent = "Chain changed. Checking Base network...";
                this.showMintInfo("Checking Base network...");
                await this.checkAndSwitchChain();
            }
            
            async checkAndSwitchChain() {
                try {
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    const isOnBase = parseInt(chainId, 16) === this.chainId;
                    
                    if (!isOnBase) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0x' + this.chainId.toString(16) }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: '0x' + this.chainId.toString(16),
                                        chainName: 'Base Mainnet',
                                        nativeCurrency: {
                                            name: 'ETH',
                                            symbol: 'ETH',
                                            decimals: 18
                                        },
                                        rpcUrls: ['https://mainnet.base.org'],
                                        blockExplorerUrls: ['https://basescan.org']
                                    }],
                                });
                            } else {
                                throw switchError;
                            }
                        }
                    }
                    
                    await this.ensureContractInitialized();
                    return true;
                } catch (error) {
                    console.error("Error switching chain:", error);
                    this.walletStatus.textContent = "Please switch to Base chain manually";
                    this.showMintInfo("Switch to Base Mainnet to mint");
                    return false;
                }
            }

            async ensureContractInitialized() {
                if (!window.ethereum || !this.isConnected) {
                    this.mintButton.disabled = true;
                    return;
                }

                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (parseInt(chainId, 16) !== this.chainId) {
                    this.mintButton.disabled = true;
                    this.showMintInfo("Switch to Base Mainnet to mint");
                    return;
                }

                if (!this.nftContract) {
                    this.initializeContract();
                } else {
                    await this.updateNFTSupply();
                    await this.checkMintEligibility();
                }
            }
            
            handleAccountsChanged(accounts) {
                if (accounts.length === 0) {
                    // User disconnected
                    this.isConnected = false;
                    this.address = null;
                    this.walletStatus.textContent = "Wallet disconnected";
                    this.connectButton.textContent = "Connect Wallet";
                    this.mintButton.classList.add('hidden');
                    this.showMintInfo("Connect your wallet on Base to mint the Early Access NFT");
                } else {
                    // User connected
                    this.isConnected = true;
                    this.address = accounts[0];
                    const shortAddress = this.address.slice(0, 6) + '...' + this.address.slice(-4);
                    this.walletStatus.textContent = `Connected: ${shortAddress}`;
                    this.connectButton.textContent = "Wallet Connected";
                    this.mintButton.classList.remove('hidden');
                    
                    // Initialize provider and contract
                    this.initializeContract();
                }
            }
            
            initializeContract() {
                try {
                    this.provider = new ethers.providers.Web3Provider(window.ethereum);
                    this.signer = this.provider.getSigner();
                    
                    const nftAbi = [
                        { "inputs": [], "name": "MAX_SUPPLY", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
                        { "inputs": [], "name": "mintNFT", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
                        { "inputs": [], "name": "remainingSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
                        { "inputs": [], "name": "playerTokenId", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
                        { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "playerTokenId", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
                    ];
                    
                    this.nftContract = new ethers.Contract(
                        this.nftContractAddress,
                        nftAbi,
                        this.signer
                    );
                    
                    this.updateNFTSupply();
                    this.checkMintEligibility();
                } catch (error) {
                    console.error("Error initializing contract:", error);
                }
            }
            
            async updateNFTSupply() {
                try {
                    const remaining = await this.nftContract.remainingSupply();
                    const remainingCount = remaining.toNumber();
                    const minted = this.maxSupply - remainingCount;
                    this.currentSupply = minted;
                    
                    this.nftMintedCount.textContent = minted;
                    const percentage = (minted / this.maxSupply) * 100;
                    this.nftProgressBar.style.width = `${Math.min(100, percentage)}%`;
                    
                    if (remainingCount <= 0) {
                        this.mintButton.disabled = true;
                        this.mintButton.textContent = "Sold Out";
                        this.showMintInfo("All 2,500 NFTs are claimed");
                    } else if (!this.isConnected) {
                        this.mintButton.disabled = true;
                        this.mintButton.textContent = "Mint NFT (Free + Gas)";
                        this.showMintInfo("Connect wallet to claim your Early Access NFT");
                    } else {
                        this.mintButton.disabled = false;
                        this.mintButton.textContent = "Mint NFT (Free + Gas)";
                    }
                } catch (error) {
                    console.error("Error updating NFT supply:", error);
                    this.showMintInfo("Unable to load supply. Please refresh.");
                }
            }
            
            async checkMintEligibility() {
                if (!this.isConnected || !this.nftContract) return;
                
                try {
                    // Check if user already has an NFT
                    // In production: const balance = await this.nftContract.balanceOf(this.address);
                    const balance = 0; // Simulate no NFTs for demo
                    
                    if (balance > 0) {
                        this.mintButton.disabled = true;
                        this.mintButton.textContent = "Already Minted";
                    } else if (this.currentSupply < this.maxSupply) {
                        this.mintButton.disabled = false;
                    }
                } catch (error) {
                    console.error("Error checking mint eligibility:", error);
                }
            }
            
            async mintNFT() {
                if (!this.isConnected || !this.nftContract) return;
                
                try {
                    this.mintButton.disabled = true;
                    this.transactionStatus.textContent = "Minting in progress...";
                    
                    // In production, this would be a real transaction:
                    // const tx = await this.nftContract.mint({ value: this.mintPrice });
                    // await tx.wait();
                    
                    // Simulate minting process for demo
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Update UI after successful mint
                    this.transactionStatus.textContent = "NFT minted successfully! 🎉";
                    this.mintButton.textContent = "Already Minted";
                    this.currentSupply++;
                    this.nftMintedCount.textContent = this.currentSupply;
                    const percentage = (this.currentSupply / this.maxSupply) * 100;
                    this.nftProgressBar.style.width = `${percentage}%`;
                    
                    // Reset status after 5 seconds
                    setTimeout(() => {
                        this.transactionStatus.textContent = "";
                    }, 5000);
                } catch (error) {
                    console.error("Error minting NFT:", error);
                    this.transactionStatus.textContent = "Minting failed. Please try again.";
                    this.mintButton.disabled = false;
                }
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new Minesweeper();
            new MinesweeperNFT();
            
            if (window.farcasterSdk &&
              window.farcasterSdk.actions &&
                typeof window.farcasterSdk.actions.ready === 'function') {
              window.farcasterSdk.actions.ready();
              console.log("✅ Mini App ready() called");
            } else {
              console.error("❌ Mini App SDK not available");
            }
        });
    </script>
</body>
</html>
