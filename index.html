<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minesweeper - Farcaster Game</title>

  <!-- Essential Open Graph Meta Tags -->
  <meta property="og:title" content="💣 Minesweeper Game" />
  <meta property="og:description" content="Can you clear the minefield? 3 difficulty levels, beat the clock, mobile-friendly!" />
  <meta property="og:image" content="https://minesweeper-game-pearl.vercel.app/assets/preview.png" />
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:url" content="https://minesweeper-game-pearl.vercel.app/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Minesweeper Game" />

  <!-- Farcaster Miniapp Meta -->
  <meta name="fc:miniapp" content='{"version":"1","imageUrl":"https://minesweeper-game-pearl.vercel.app/assets/preview.png","button":{"title":"Play","action":{"type":"launch_frame","name":"Minesweeper","url":"https://minesweeper-game-pearl.vercel.app/","splashImageUrl":"https://minesweeper-game-pearl.vercel.app/assets/splash.png","splashBackgroundColor":"#667eea"}}}' />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="💣 Minesweeper Game" />
  <meta name="twitter:description" content="Can you clear the minefield? Play Minesweeper on Farcaster!" />
  <meta name="twitter:image" content="https://minesweeper-game-pearl.vercel.app/assets/preview.png" />

  <meta name="description" content="Play Minesweeper on Farcaster! Mobile-friendly game with 3 difficulty levels. Share your results and challenge friends." />
  <meta name="keywords" content="minesweeper, farcaster, game, puzzle, mobile, web3" />
  <meta name="author" content="vidhyadar.base.eth" />

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk'
    window.farcasterSdk = sdk;
  </script>

  <style>
    * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 400px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            font-size: 0.9rem;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2rem;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .difficulty-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .difficulty-btn {
            padding: 8px 12px;
            font-size: 0.8rem;
            min-width: 60px;
        }

        .difficulty-btn.active {
            background: rgba(255, 255, 255, 0.4);
            font-weight: bold;
        }

        /* Enhanced mode toggle button styling */
        #toggle-mode {
            position: relative;
            overflow: hidden;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #toggle-mode.dig-mode {
            background: rgba(76, 175, 80, 0.8);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
        }

        #toggle-mode.flag-mode {
            background: rgba(244, 67, 54, 0.8);
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.3);
        }

        #toggle-mode:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .minefield {
            display: grid;
            gap: 2px;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto;
            max-width: 100%;
            overflow: auto;
        }

        .cell {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(255, 255, 255, 0.8);
            color: #333;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }

        .cell.revealed {
            background: rgba(255, 255, 255, 0.6);
            cursor: default;
        }

        .cell.revealed:hover {
            transform: none;
        }

        .cell.flagged {
            background: rgba(255, 100, 100, 0.8);
            color: white;
        }

        .cell.mine {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            animation: explode 0.5s ease-out;
        }

        .cell.false-flag {
            background: rgba(255, 69, 0, 0.9);
            color: white;
            animation: shake 0.5s ease-out;
        }

        @keyframes explode {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        .cell.number-1 { color: #0066cc; }
        .cell.number-2 { color: #009900; }
        .cell.number-3 { color: #ff0000; }
        .cell.number-4 { color: #000080; }
        .cell.number-5 { color: #800000; }
        .cell.number-6 { color: #008080; }
        .cell.number-7 { color: #000000; }
        .cell.number-8 { color: #808080; }

        .game-message {
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .game-message.win {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }

        .game-message.lose {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6666;
        }

        .instructions {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.8rem;
            text-align: center;
            line-height: 1.4;
        }

        .share-section {
            margin-top: 15px;
            text-align: center;
        }

        .share-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .share-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(138, 43, 226, 0.8);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .share-btn:hover {
            background: rgba(138, 43, 226, 1);
            transform: translateY(-2px);
        }

        .share-btn.warpcast {
            background: rgba(139, 69, 255, 0.8);
        }

        .share-btn.warpcast:hover {
            background: rgba(139, 69, 255, 1);
        }

        .share-result {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 8px;
            color: #00ff88;
            font-size: 0.9rem;
            border: 1px solid rgba(0, 255, 0, 0.3);
            display: none;
        }

        /* Wallet connection section styling */
        .wallet-section {
            margin: 15px 0;
            text-align: center;
        }

        .wallet-btn {
            background: rgba(0, 150, 255, 0.8);
            font-weight: bold;
            min-width: 140px;
        }

        .wallet-btn:hover {
            background: rgba(0, 150, 255, 1);
            transform: translateY(-2px);
        }

        .wallet-btn.connected {
            background: rgba(0, 200, 100, 0.8);
        }

        .wallet-btn.connected:hover {
            background: rgba(0, 200, 100, 1);
        }

        .wallet-status {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.8rem;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            flex-direction: column;
        }

        .wallet-status #wallet-address {
            font-family: monospace;
            color: #00ff88;
            font-weight: bold;
        }

        .chain-indicator {
            font-size: 0.7rem;
            color: #66aaff;
            margin-top: 2px;
        }

        .chain-indicator.base {
            color: #00ff88;
        }

        /* Disabled state for game elements when wallet not connected */
        .game-disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* Sound toggle button */
        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 15px;
                margin: 10px;
            }
            
            .game-title {
                font-size: 1.5rem;
            }
            
            .cell {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }
            
            .difficulty-buttons {
                flex-wrap: wrap;
            }
            
            .btn {
                font-size: 0.8rem;
                padding: 8px 15px;
            }

            .sound-toggle {
                top: 10px;
                right: 10px;
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }
  </style>
</head>
<body>
  <!-- Sound toggle button -->
  <button class="sound-toggle" id="sound-toggle">🔊</button>

  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">💣 Minesweeper</h1>
    </div>

    <div class="difficulty-buttons">
      <button class="btn difficulty-btn active" data-difficulty="easy">Easy</button>
      <button class="btn difficulty-btn" data-difficulty="medium">Medium</button>
      <button class="btn difficulty-btn" data-difficulty="hard">Hard</button>
    </div>

    <div class="game-stats">
      <div class="stat">
        <span>Mines</span>
        <span class="stat-value" id="mines-count">10</span>
      </div>
      <div class="stat">
        <span>Flags</span>
        <span class="stat-value" id="flags-count">0</span>
      </div>
      <div class="stat">
        <span>Time</span>
        <span class="stat-value" id="timer">0</span>
      </div>
    </div>

    <div class="game-controls">
      <button class="btn" id="new-game">New Game</button>
      <button class="btn dig-mode" id="toggle-mode">👆 Reveal Mode</button>
    </div>

    <!-- Wallet Connection Section -->
    <div class="wallet-section" id="wallet-section">
      <button class="btn wallet-btn" id="connect-wallet">🔗 Connect Wallet</button>
      <div class="wallet-status" id="wallet-status" style="display: none;">
        <div>
          <span>👤 Connected: </span>
          <span id="wallet-address"></span>
        </div>
        <div class="chain-indicator" id="chain-indicator">Checking network...</div>
      </div>
      <div style="margin-top:10px;">
        <button class="share-btn" id="mint-early-btn" style="display:none;">🎟️ Mint Early Adopter NFT</button>
        <span id="mint-status" style="display:none;font-size:0.8rem;margin-left:8px;"></span>
        <div id="mint-remaining" style="display:none;font-size:0.78rem;margin-top:6px;color:#cde;">Remaining: --</div>
      </div>
    </div>

    <div class="minefield" id="minefield"></div>
    <div class="game-message" id="game-message"></div>

    <div class="share-section">
      <div class="share-result" id="share-result">Link copied to clipboard! 📋</div>
      <div class="share-buttons">
        <button class="share-btn" id="share-warpcast">🟣 Share on Warpcast</button>
        <button class="share-btn" id="share-general">🔗 Copy Game Link</button>
        <button class="share-btn" id="share-result-btn" style="display: none;">🏆 Share Result</button>
      </div>
    </div>

    <div class="instructions">
      <strong>How to play:</strong><br>
      • Tap to reveal cells<br>
      • Use Flag Mode to mark mines<br>
      • Numbers show nearby mines<br>
      • Find all mines to win!
    </div>
  </div>

  <script>
    // Global variables for Farcaster wallet
    let walletConnected = false;
    let provider, signer, userAddress, farcasterUser;
    let walletConnectProvider = null;

    // Enhanced wallet detection for mobile environments
    function detectWalletProviders() {
      const providers = [];
      
      // Check for various wallet providers
      if (window.ethereum) {
        providers.push({
          name: 'MetaMask',
          provider: window.ethereum,
          isMetaMask: window.ethereum.isMetaMask,
          isCoinbaseWallet: window.ethereum.isCoinbaseWallet,
          isRabby: window.ethereum.isRabby,
          isBraveWallet: window.ethereum.isBraveWallet
        });
      }
      
      // Check for WalletConnect
      if (window.WalletConnectProvider) {
        providers.push({
          name: 'WalletConnect',
          provider: window.WalletConnectProvider
        });
      }
      
      // Check for Farcaster embedded wallet
      if (window.farcasterSdk) {
        providers.push({
          name: 'Farcaster',
          provider: window.farcasterSdk
        });
      }
      
      // Check for mobile-specific providers
      if (window.web3) {
        providers.push({
          name: 'Web3',
          provider: window.web3.currentProvider
        });
      }
      
      return providers;
    }

    // Connect wallet function with better error handling and mobile support
    async function connectWallet() {
      if (walletConnected) return true;
      
      // Update button state
      const connectBtn = document.getElementById('connect-wallet');
      connectBtn.textContent = '⏳ Connecting...';
      connectBtn.disabled = true;
      
      try {
        const providers = detectWalletProviders();
        console.log("Detected wallet providers:", providers.map(p => p.name));
        
        if (providers.length === 0) {
          throw new Error("No wallet provider found. Please install a wallet or use Farcaster mobile app.");
        }
        
        // Try each provider in order of preference
        for (const walletProvider of providers) {
          try {
            console.log(`Trying ${walletProvider.name}...`);
            
            if (walletProvider.name === 'Farcaster') {
              const success = await connectFarcasterWallet();
              if (success) return true;
            } else if (walletProvider.name === 'WalletConnect') {
              const success = await connectWalletConnect();
              if (success) return true;
            } else {
              const success = await connectStandardWallet(walletProvider);
              if (success) return true;
            }
          } catch (err) {
            console.log(`${walletProvider.name} connection failed:`, err.message);
            continue;
          }
        }
        
        throw new Error("All wallet connection attempts failed. Please try a different wallet.");
        
      } catch (err) {
        console.error("❌ All wallet connection attempts failed:", err);
        
        // Reset button
        connectBtn.textContent = '🔗 Connect Wallet';
        connectBtn.disabled = false;
        
        if (window.gameInstance) {
          window.gameInstance.showShareResult(`❌ Connection failed: ${err.message}`, "error");
        } else {
          alert(`Wallet connection failed: ${err.message}`);
        }
        return false;
      }
    }

    // Standard wallet connection (MetaMask, Coinbase, etc.)
    async function connectStandardWallet(walletProvider) {
      try {
        console.log(`Connecting to ${walletProvider.name}...`);
        
        // Switch to Base chain first
        await switchToBaseChain();
        
        provider = new ethers.providers.Web3Provider(walletProvider.provider);
        
        // Request account access
        const accounts = await provider.send("eth_requestAccounts", []);
        if (!accounts || accounts.length === 0) {
          throw new Error(`No accounts found in ${walletProvider.name}`);
        }
        
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        
        console.log(`${walletProvider.name} connected, address:`, userAddress);
        
        // Request signature for authentication
        const message = `Sign in to Minesweeper Game\nAddress: ${userAddress}\nTime: ${new Date().toISOString()}`;
        
        try {
          const signature = await signer.signMessage(message);
          console.log(`✅ ${walletProvider.name} message signed successfully`);
          
          walletConnected = true;
          await updateWalletUI();
          
          if (window.gameInstance) {
            window.gameInstance.showShareResult(`🦊 ${walletProvider.name} connected successfully on Base!`, "success");
            window.gameInstance.enableGame();
          }
          
          return true;
          
        } catch (signError) {
          if (signError.code === 4001) {
            throw new Error("Please sign the message to authenticate");
          } else {
            throw new Error("Signature failed: " + signError.message);
          }
        }
        
      } catch (err) {
        console.error(`${walletProvider.name} connection failed:`, err);
        if (err.code === 4001) {
          throw new Error(`Please connect your ${walletProvider.name} wallet`);
        } else if (err.code === -32002) {
          throw new Error(`${walletProvider.name} connection request pending. Please check your wallet.`);
        } else {
          throw err;
        }
      }
    }

    // WalletConnect connection
    async function connectWalletConnect() {
      try {
        console.log("Initializing WalletConnect...");
        
        // Initialize WalletConnect provider
        walletConnectProvider = new window.WalletConnectProvider.default({
          rpc: {
            8453: "https://mainnet.base.org", // Base mainnet
            1: "https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161" // Ethereum mainnet fallback
          },
          chainId: 8453, // Default to Base
          qrcode: true,
          pollingInterval: 12000
        });
        
        // Enable session (triggers QR Code modal)
        await walletConnectProvider.enable();
        
        provider = new ethers.providers.Web3Provider(walletConnectProvider);
        const accounts = await provider.listAccounts();
        
        if (!accounts || accounts.length === 0) {
          throw new Error("No accounts found in WalletConnect");
        }
        
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        
        console.log("WalletConnect connected, address:", userAddress);
        
        // Request signature for authentication
        const message = `Sign in to Minesweeper Game\nAddress: ${userAddress}\nTime: ${new Date().toISOString()}`;
        const signature = await signer.signMessage(message);
        console.log("✅ WalletConnect message signed successfully");
        
        walletConnected = true;
        await updateWalletUI();
        
        if (window.gameInstance) {
          window.gameInstance.showShareResult(`🔗 WalletConnect connected successfully on Base!`, "success");
          window.gameInstance.enableGame();
        }
        
        return true;
        
      } catch (err) {
        console.error("WalletConnect connection failed:", err);
        throw err;
      }
    }

    // Enhanced Farcaster wallet connection
    async function connectFarcasterWallet() {
      try {
        console.log("Available Farcaster SDK methods:", Object.keys(window.farcasterSdk));
        
        // Get user context from Farcaster SDK
        const context = await window.farcasterSdk.context;
        console.log("Farcaster context:", context);
        
        if (!context || !context.user) {
          throw new Error("No Farcaster user context available. Please ensure you're using the Farcaster mobile app.");
        }
        
        // Store Farcaster user data
        farcasterUser = context.user;
        console.log("Farcaster user:", farcasterUser);
        
        // Try to find an Ethereum provider in the Farcaster environment
        let ethereumProvider = null;
        
        // Check multiple possible provider locations
        if (window.ethereum) {
          ethereumProvider = window.ethereum;
        } else if (window.web3 && window.web3.currentProvider) {
          ethereumProvider = window.web3.currentProvider;
        } else if (window.farcasterSdk.ethereum) {
          ethereumProvider = window.farcasterSdk.ethereum;
        } else if (context.ethereum) {
          ethereumProvider = context.ethereum;
        }
        
        if (!ethereumProvider) {
          // Try to create a provider using Farcaster SDK methods
          try {
            // Some Farcaster implementations might expose wallet methods directly
            if (window.farcasterSdk.wallet) {
              ethereumProvider = window.farcasterSdk.wallet;
            } else if (window.farcasterSdk.getProvider) {
              ethereumProvider = await window.farcasterSdk.getProvider();
            }
          } catch (providerError) {
            console.log("Could not get provider from Farcaster SDK:", providerError);
          }
        }
        
        if (ethereumProvider) {
          // Switch to Base chain if not already on it
          await switchToBaseChain();
          
          provider = new ethers.providers.Web3Provider(ethereumProvider);
          const accounts = await provider.send("eth_requestAccounts", []);
          
          if (!accounts || accounts.length === 0) {
            throw new Error("No accounts found in Farcaster wallet");
          }
          
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          
          console.log("✅ Wallet connected via Farcaster context");
          
          // Request signature for authentication
          const message = `Sign in to Minesweeper Game\nAddress: ${userAddress}\nTime: ${new Date().toISOString()}`;
          const signature = await signer.signMessage(message);
          console.log("✅ Message signed successfully");
          
          walletConnected = true;
          await updateWalletUI();
          
          if (window.gameInstance) {
            window.gameInstance.showShareResult(`🎉 Farcaster wallet connected! Welcome ${farcasterUser.displayName || farcasterUser.username || 'User'}!`, "success");
            window.gameInstance.enableGame();
          }
          
          return true;
        } else {
          // Fallback: Try to use WalletConnect if no direct provider
          console.log("No direct Ethereum provider found, trying WalletConnect...");
          return await connectWalletConnect();
        }
        
      } catch (err) {
        console.error("Farcaster connection failed:", err);
        throw err;
      }
    }

    // Switch to Base chain
    async function switchToBaseChain() {
      try {
        const baseChainId = '0x2105'; // 8453 in hex
        const baseChainConfig = {
          chainId: baseChainId,
          chainName: 'Base',
          rpcUrls: ['https://mainnet.base.org'],
          nativeCurrency: {
            name: 'Ethereum',
            symbol: 'ETH',
            decimals: 18
          },
          blockExplorerUrls: ['https://basescan.org']
        };

        try {
          // Try to switch to Base chain
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: baseChainId }],
          });
          console.log("✅ Switched to Base chain");
        } catch (switchError) {
          // If the chain doesn't exist, add it
          if (switchError.code === 4902) {
            try {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [baseChainConfig],
              });
              console.log("✅ Added and switched to Base chain");
            } catch (addError) {
              throw new Error("Failed to add Base chain: " + addError.message);
            }
          } else {
            throw new Error("Failed to switch to Base chain: " + switchError.message);
          }
        }
      } catch (err) {
        console.error("Base chain switch failed:", err);
        throw new Error("Please switch to Base chain manually in your wallet");
      }
    }


    // Update wallet UI
    async function updateWalletUI() {
      const connectBtn = document.getElementById('connect-wallet');
      const walletStatus = document.getElementById('wallet-status');
      const walletAddress = document.getElementById('wallet-address');
      const chainIndicator = document.getElementById('chain-indicator');
      
      if (walletConnected && userAddress) {
        connectBtn.textContent = '✅ Connected';
        connectBtn.classList.add('connected');
        connectBtn.disabled = false;
        
        walletStatus.style.display = 'flex';
        walletAddress.textContent = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
        
        // Update chain indicator
        try {
          if (provider) {
            const network = await provider.getNetwork();
            if (network.chainId === 8453) {
              chainIndicator.textContent = '🔗 Base Chain';
              chainIndicator.classList.add('base');
            } else {
              chainIndicator.textContent = `⚠️ Chain ID: ${network.chainId}`;
              chainIndicator.classList.remove('base');
            }
          } else {
            chainIndicator.textContent = '❓ Unknown Network';
          }
        } catch (err) {
          chainIndicator.textContent = '❌ Network Error';
        }
        
        // Enable game elements
        document.querySelectorAll('.difficulty-btn, #new-game, #toggle-mode').forEach(el => {
          el.classList.remove('game-disabled');
        });
        document.getElementById('minefield').classList.remove('game-disabled');

        // Show mint button if on Base
        try {
          const net = await provider.getNetwork();
          document.getElementById('mint-early-btn').style.display = (net.chainId === 8453) ? 'inline-flex' : 'none';
        } catch (_) {}
        
      } else {
        connectBtn.textContent = '🔗 Connect Wallet';
        connectBtn.classList.remove('connected');
        connectBtn.disabled = false;
        
        walletStatus.style.display = 'none';
        
        // Disable game elements
        document.querySelectorAll('.difficulty-btn, #new-game, #toggle-mode').forEach(el => {
          el.classList.add('game-disabled');
        });
        document.getElementById('minefield').classList.add('game-disabled');
        document.getElementById('mint-early-btn').style.display = 'none';
      }
    }

    // Early Adopter NFT config (deployed SimpleMinesweeperNFT)
    const EARLY_NFT = {
      address: '0x1870C2c5AC9BBa4682Bde79FB67B700c01128F0b', // Deployed on Base mainnet
      abi: [
        { "inputs": [], "name": "mintNFT", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
        { "inputs": [], "name": "MAX_SUPPLY", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}], "stateMutability": "view", "type": "function" },
        { "inputs": [], "name": "totalSupply", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}], "stateMutability": "view", "type": "function" },
        { "inputs": [], "name": "remainingSupply", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}], "stateMutability": "view", "type": "function" },
        { "inputs": [{"internalType":"address","name":"","type":"address"}], "name": "playerTokenId", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}], "stateMutability": "view", "type": "function" }
      ]
    };

    async function refreshMintUI() {
      try {
        const mintBtn = document.getElementById('mint-early-btn');
        const statusEl = document.getElementById('mint-status');
        const remainingEl = document.getElementById('mint-remaining');
        statusEl.style.display = 'inline';

        if (EARLY_NFT.address === '0x0000000000000000000000000000000000000000') {
          mintBtn.style.display = 'none';
          statusEl.textContent = 'Configure NFT contract address to enable mint.';
          remainingEl.style.display = 'none';
          return;
        }

        const net = await provider.getNetwork();
        if (net.chainId !== 8453) {
          mintBtn.style.display = 'none';
          statusEl.textContent = 'Switch to Base to mint.';
          remainingEl.style.display = 'none';
          return;
        }

        const contract = new ethers.Contract(EARLY_NFT.address, EARLY_NFT.abi, provider);
        const [remaining, tokenId] = await Promise.all([
          contract.remainingSupply(),
          contract.playerTokenId(userAddress)
        ]);

        if (remaining.toString() === '0') {
          mintBtn.style.display = 'none';
          statusEl.textContent = 'Sold out';
          remainingEl.style.display = 'inline';
          remainingEl.textContent = 'Remaining: 0';
          return;
        }

        if (tokenId.toString() !== '0') {
          mintBtn.style.display = 'none';
          statusEl.textContent = `You already minted #${tokenId.toString()}`;
          remainingEl.style.display = 'inline';
          remainingEl.textContent = `Remaining: ${remaining.toString()}`;
          return;
        }

        mintBtn.style.display = 'inline-flex';
        statusEl.textContent = `${remaining.toString()} left`;
        remainingEl.style.display = 'inline';
        remainingEl.textContent = `Remaining: ${remaining.toString()}`;
      } catch (e) {
        console.log('Mint UI refresh failed:', e);
        const mintBtn = document.getElementById('mint-early-btn');
        const statusEl = document.getElementById('mint-status');
        const remainingEl = document.getElementById('mint-remaining');
        statusEl.style.display = 'inline';
        statusEl.textContent = '';
        // keep button hidden on error
        mintBtn.style.display = 'none';
        remainingEl.style.display = 'none';
      }
    }

    async function mintEarlyAdopter() {
      try {
        if (!walletConnected) {
          window.gameInstance.showShareResult('Please connect your wallet first! 🔗', 'error');
          return;
        }
        const net = await provider.getNetwork();
        if (net.chainId !== 8453) {
          await switchToBaseChain();
        }

        if (EARLY_NFT.address === '0x0000000000000000000000000000000000000000') {
          window.gameInstance.showShareResult('Contract not configured yet. Please try later.', 'error');
          return;
        }

        const contract = new ethers.Contract(EARLY_NFT.address, EARLY_NFT.abi, signer);
        const btn = document.getElementById('mint-early-btn');
        const statusEl = document.getElementById('mint-status');
        const remainingEl = document.getElementById('mint-remaining');
        btn.disabled = true;
        statusEl.style.display = 'inline';
        statusEl.textContent = '⏳ Checking eligibility...';

        // Pre-flight checks to avoid simulation failure
        try {
          const [remaining, tokenId] = await Promise.all([
            contract.remainingSupply(),
            contract.playerTokenId(userAddress)
          ]);
          if (remaining.toString() === '0') {
            window.gameInstance.showShareResult('Sold out.', 'error');
            await refreshMintUI();
            return;
          }
          if (tokenId.toString() !== '0') {
            window.gameInstance.showShareResult(`You already minted #${tokenId.toString()}.`, 'info');
            await refreshMintUI();
            return;
          }
        } catch (preErr) {
          console.error('Pre-check failed:', preErr);
          // continue; some RPCs may block simulation but tx may still succeed
        }

        statusEl.textContent = '⏳ Minting...';

        const tx = await contract.mintNFT({ gasLimit: 220000 });
        window.gameInstance.showShareResult('⏳ Waiting for confirmation...', 'info');
        await tx.wait();

        statusEl.textContent = '✅ Minted!';
        window.gameInstance.showShareResult('✅ Early Adopter NFT minted!', 'success');
        await refreshMintUI();
      } catch (e) {
        console.error(e);
        window.gameInstance.showShareResult(e?.message || 'Mint failed', 'error');
      } finally {
        const btn = document.getElementById('mint-early-btn');
        const statusEl = document.getElementById('mint-status');
        const remainingEl = document.getElementById('mint-remaining');
        btn.disabled = false;
        setTimeout(() => { statusEl.style.display = 'none'; }, 2000);
      }
    }

    // NFT minting function with Farcaster integration
    async function captureAndMint(result) {
      try {
        // Capture game screenshot
        const canvas = await html2canvas(document.querySelector(".game-container"));
        const image = canvas.toDataURL("image/png");

        // Create enhanced metadata with Farcaster info
        const metadata = {
          name: `Minesweeper - ${result.win ? "Victory" : "Defeat"}`,
          description: `Difficulty: ${result.difficulty}, Time: ${result.time}s, Result: ${result.win ? "Win" : "Loss"}${result.farcasterUser ? ` by @${result.farcasterUser.username || result.farcasterUser.displayName || 'Anonymous'}` : ''}`,
          image: image,
          attributes: [
            { trait_type: "Difficulty", value: result.difficulty },
            { trait_type: "Time", value: result.time },
            { trait_type: "Result", value: result.win ? "Win" : "Lose" },
            { trait_type: "Player", value: result.farcasterUser?.username || result.farcasterUser?.displayName || "Anonymous" },
            { trait_type: "Platform", value: "Farcaster" }
          ]
        };

        const tokenURI = "data:application/json;base64," + btoa(JSON.stringify(metadata));

        // Check if we're on Base chain first
        const network = await provider.getNetwork();
        if (network.chainId !== 8453) {
          throw new Error("Please switch to Base chain to mint NFTs");
        }

        // TODO: Replace with your deployed contract address from Remix
        const CONTRACT_ADDRESS = "0x1870C2c5AC9BBa4682Bde79FB67B700c01128F0b"; // Your deployed contract address
        const CONTRACT_ABI = [
          {
            "inputs": [
              {"internalType": "string", "name": "difficulty", "type": "string"},
              {"internalType": "uint256", "name": "time", "type": "uint256"},
              {"internalType": "bool", "name": "win", "type": "bool"},
              {"internalType": "string", "name": "playerName", "type": "string"},
              {"internalType": "string", "name": "imageHash", "type": "string"}
            ],
            "name": "mintGameResult",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ];

        // Check if contract is deployed
        if (CONTRACT_ADDRESS === "0x1c0EaF74aDf6017ed1519aAc4e672e1C24CB6B93") {
          // Fallback to simple transaction if contract not deployed
          window.gameInstance.showShareResult("⏳ Creating game result record...", "info");
          
          const gameResultHash = ethers.utils.keccak256(
            ethers.utils.toUtf8Bytes(
              `${userAddress}-${result.difficulty}-${result.time}-${result.win}-${Date.now()}`
            )
          );
          
          try {
            const gasPrice = await provider.getGasPrice();
            const gasLimit = 100000;
            
            const tx = await signer.sendTransaction({
              to: userAddress,
              value: 0,
              gasLimit: gasLimit,
              gasPrice: gasPrice,
              data: ethers.utils.toUtf8Bytes(`Minesweeper Result: ${JSON.stringify({
                hash: gameResultHash,
                difficulty: result.difficulty,
                time: result.time,
                win: result.win,
                timestamp: Date.now(),
                player: result.farcasterUser?.username || result.farcasterUser?.displayName || 'Anonymous'
              })}`)
            });
            
            window.gameInstance.showShareResult("⏳ Recording result on Base chain...", "info");
            await tx.wait();
            
            window.gameInstance.showShareResult("✅ Game result recorded on Base chain! 🎉", "success");
            console.log("✅ Game result recorded:", {
              txHash: tx.hash,
              gameHash: gameResultHash,
              baseScanUrl: `https://basescan.org/tx/${tx.hash}`
            });
            
          } catch (txError) {
            console.error("Transaction failed:", txError);
            window.gameInstance.showShareResult("✅ Game result saved locally! 🎉", "success");
          }
        } else {
          // Use deployed NFT contract
          const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
          
          window.gameInstance.showShareResult("⏳ Minting NFT on Base chain...", "info");
          
          const tx = await contract.mintGameResult(
            result.difficulty,
            result.time,
            result.win,
            result.farcasterUser?.username || result.farcasterUser?.displayName || 'Anonymous',
            image, // Base64 encoded image
            {
              gasLimit: 500000
            }
          );
          
          window.gameInstance.showShareResult("⏳ Waiting for confirmation...", "info");
          await tx.wait();
          
          window.gameInstance.showShareResult("✅ NFT Minted Successfully! 🎉", "success");
          console.log("✅ NFT Minted:", {
            txHash: tx.hash,
            contractAddress: CONTRACT_ADDRESS,
            baseScanUrl: `https://basescan.org/tx/${tx.hash}`
          });
        }
        
        // Share on Farcaster if SDK available
        if (window.farcasterSdk && result.farcasterUser) {
          try {
            const shareText = `🎮 Just minted my Minesweeper result as an NFT!\n${result.win ? '🏆 Victory!' : '💣 Game Over'}\nDifficulty: ${result.difficulty}\nTime: ${result.time}s`;
            
            // Use Farcaster SDK to share (if available)
            if (window.farcasterSdk.actions.cast) {
              await window.farcasterSdk.actions.cast({
                text: shareText,
                embeds: [window.location.href]
              });
            }
          } catch (shareError) {
            console.log("Auto-share failed, but NFT was minted successfully");
          }
        }
        
      } catch (err) {
        console.error("❌ Mint failed:", err);
        let errorMsg = "❌ NFT minting failed: ";
        
        if (err.message.includes("user rejected")) {
          errorMsg += "Transaction was cancelled";
        } else if (err.message.includes("insufficient funds")) {
          errorMsg += "Insufficient funds for gas";
        } else {
          errorMsg += err.message || "Unknown error";
        }
        
        window.gameInstance.showShareResult(errorMsg, "error");
      }
    }

    // Minesweeper Game Class
    class Minesweeper {
      constructor() {
        this.gameState = 'ready';
        this.flagMode = false;
        this.firstClick = true;
        this.timer = 0;
        this.timerInterval = null;
        this.soundEnabled = true;

        this.difficulties = {
          easy: { rows: 9, cols: 9, mines: 10 },
          medium: { rows: 12, cols: 12, mines: 20 },
          hard: { rows: 15, cols: 15, mines: 35 }
        };

        this.currentDifficulty = 'easy';
        this.config = this.difficulties.easy;
        this.board = [];
        this.revealed = [];
        this.flagged = [];

        this.createSounds();
        this.initializeGame();
        this.setupEventListeners();
      }

      createSounds() {
        // Create sound effects using Web Audio API
        this.audioContext = null;
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Audio not supported');
        }
      }

      playSound(frequency = 440, duration = 200, type = 'sine') {
        if (!this.soundEnabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        // Reduced volume for a softer UX
        gainNode.gain.setValueAtTime(0.12, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.005, this.audioContext.currentTime + duration / 1000);

        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration / 1000);
      }

      initializeGame() {
        this.gameState = 'ready';
        this.firstClick = true;
        this.timer = 0;
        this.clearTimer();
        
        this.config = this.difficulties[this.currentDifficulty];
        this.board = [];
        this.revealed = [];
        this.flagged = [];

        // Initialize empty board
        for (let i = 0; i < this.config.rows; i++) {
          this.board[i] = [];
          this.revealed[i] = [];
          this.flagged[i] = [];
          for (let j = 0; j < this.config.cols; j++) {
            this.board[i][j] = 0;
            this.revealed[i][j] = false;
            this.flagged[i][j] = false;
          }
        }

        this.updateDisplay();
        this.renderBoard();
        document.getElementById('game-message').textContent = '';
        document.getElementById('share-result-btn').style.display = 'none';
      }

      placeMines(excludeRow, excludeCol) {
        let minesPlaced = 0;
        while (minesPlaced < this.config.mines) {
          const row = Math.floor(Math.random() * this.config.rows);
          const col = Math.floor(Math.random() * this.config.cols);
          
          // Don't place mine on first click or if already has mine
          if ((row === excludeRow && col === excludeCol) || this.board[row][col] === -1) {
            continue;
          }
          
          this.board[row][col] = -1; // -1 represents a mine
          minesPlaced++;
        }

        // Calculate numbers for each cell
        for (let i = 0; i < this.config.rows; i++) {
          for (let j = 0; j < this.config.cols; j++) {
            if (this.board[i][j] !== -1) {
              this.board[i][j] = this.countAdjacentMines(i, j);
            }
          }
        }
      }

      countAdjacentMines(row, col) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            const newRow = row + i;
            const newCol = col + j;
            if (newRow >= 0 && newRow < this.config.rows && 
                newCol >= 0 && newCol < this.config.cols && 
                this.board[newRow][newCol] === -1) {
              count++;
            }
          }
        }
        return count;
      }

      renderBoard() {
        const minefield = document.getElementById('minefield');
        minefield.innerHTML = '';
        minefield.style.gridTemplateColumns = `repeat(${this.config.cols}, 32px)`;
        minefield.style.gridTemplateRows = `repeat(${this.config.rows}, 32px)`;

        for (let i = 0; i < this.config.rows; i++) {
          for (let j = 0; j < this.config.cols; j++) {
            const cell = document.createElement('button');
            cell.className = 'cell';
            cell.dataset.row = i;
            cell.dataset.col = j;
            
            cell.addEventListener('click', (e) => {
              e.preventDefault();
              this.handleCellClick(i, j);
            });

            minefield.appendChild(cell);
          }
        }

        this.updateBoard();
      }

      updateBoard() {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          
          cell.className = 'cell';
          cell.textContent = '';

          if (this.flagged[row][col]) {
            cell.classList.add('flagged');
            cell.textContent = '🚩';
          } else if (this.revealed[row][col]) {
            cell.classList.add('revealed');
            if (this.board[row][col] === -1) {
              cell.classList.add('mine');
              cell.textContent = '💣';
            } else if (this.board[row][col] > 0) {
              cell.textContent = this.board[row][col];
              cell.classList.add(`number-${this.board[row][col]}`);
            }
          }
        });
      }

      async handleCellClick(row, col) {
        // Check if wallet is connected before allowing any gameplay
        if (!walletConnected) {
          this.showShareResult('Please connect your wallet first! 🔗', 'error');
          return;
        }

        if (this.gameState !== 'ready' && this.gameState !== 'playing') return;
        if (this.revealed[row][col]) return;

        if (this.flagMode) {
          this.toggleFlag(row, col);
          return;
        }

        // First click - place mines
        if (this.firstClick) {
          this.placeMines(row, col);
          this.firstClick = false;
          this.gameState = 'playing';
          this.startTimer();
        }

        if (this.flagged[row][col]) return;

        this.revealCell(row, col);
        this.playSound(800, 100);

        if (this.board[row][col] === -1) {
          this.gameOver(false);
        } else if (this.checkWin()) {
          this.gameOver(true);
        }

        this.updateBoard();
        this.updateDisplay();
      }

      revealCell(row, col) {
        if (row < 0 || row >= this.config.rows || col < 0 || col >= this.config.cols) return;
        if (this.revealed[row][col] || this.flagged[row][col]) return;

        this.revealed[row][col] = true;

        // Auto-reveal adjacent cells if this cell has no adjacent mines
        if (this.board[row][col] === 0) {
          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              this.revealCell(row + i, col + j);
            }
          }
        }
      }

      toggleFlag(row, col) {
        if (this.revealed[row][col]) return;

        this.flagged[row][col] = !this.flagged[row][col];
        this.playSound(600, 150);
        this.updateBoard();
        this.updateDisplay();
      }

      checkWin() {
        for (let i = 0; i < this.config.rows; i++) {
          for (let j = 0; j < this.config.cols; j++) {
            if (this.board[i][j] !== -1 && !this.revealed[i][j]) {
              return false;
            }
          }
        }
        return true;
      }

      gameOver(won) {
        this.gameState = won ? 'won' : 'lost';
        this.clearTimer();

        if (won) {
          this.playSound(880, 500, 'triangle');
          document.getElementById('game-message').textContent = '🎉 You won!';
          document.getElementById('game-message').className = 'game-message win';
        } else {
          this.playSound(220, 800, 'sawtooth');
          document.getElementById('game-message').textContent = '💥 Game over!';
          document.getElementById('game-message').className = 'game-message lose';
          
          // Reveal all mines
          for (let i = 0; i < this.config.rows; i++) {
            for (let j = 0; j < this.config.cols; j++) {
              if (this.board[i][j] === -1) {
                this.revealed[i][j] = true;
              }
              if (this.flagged[i][j] && this.board[i][j] !== -1) {
                document.querySelector(`[data-row="${i}"][data-col="${j}"]`).classList.add('false-flag');
              }
            }
          }
        }

        document.getElementById('share-result-btn').style.display = 'inline-flex';
        this.updateBoard();
      }

      startTimer() {
        this.timerInterval = setInterval(() => {
          this.timer++;
          document.getElementById('timer').textContent = this.timer;
        }, 1000);
      }

      clearTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
      }

      updateDisplay() {
        document.getElementById('mines-count').textContent = this.config.mines;
        
        const flagCount = this.flagged.flat().filter(Boolean).length;
        document.getElementById('flags-count').textContent = flagCount;
        document.getElementById('timer').textContent = this.timer;
      }

      toggleMode() {
        this.flagMode = !this.flagMode;
        const button = document.getElementById('toggle-mode');
        
        if (this.flagMode) {
          button.textContent = '🚩 Flag Mode';
          button.className = 'btn flag-mode';
        } else {
          button.textContent = '👆 Reveal Mode';
          button.className = 'btn dig-mode';
        }
      }

      changeDifficulty(difficulty) {
        if (this.gameState === 'playing') {
          if (!confirm('This will start a new game. Continue?')) return;
        }

        this.currentDifficulty = difficulty;
        
        // Update active button
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-difficulty="${difficulty}"]`).classList.add('active');
        
        this.initializeGame();
      }

      shareToWarpcast() {
        const gameUrl = window.location.href;
        const text = encodeURIComponent('🎮 Playing Minesweeper! Can you beat my score?');
        const warpcastUrl = `https://warpcast.com/~/compose?text=${text}&embeds[]=${encodeURIComponent(gameUrl)}`;
        window.open(warpcastUrl, '_blank');
      }

      copyGameLink() {
        const gameUrl = window.location.href;
        navigator.clipboard.writeText(gameUrl).then(() => {
          this.showShareResult('Game link copied to clipboard! 📋');
        }).catch(() => {
          this.showShareResult('Failed to copy link. Try again!', 'error');
        });
      }

      shareResult() {
        const result = this.gameState === 'won' ? 'Won' : 'Lost';
        const text = `🎮 Minesweeper Result: ${result}!\nDifficulty: ${this.currentDifficulty}\nTime: ${this.timer}s\n\nPlay here: ${window.location.href}`;
        
        if (navigator.share) {
          navigator.share({
            title: 'Minesweeper Game Result',
            text: text,
            url: window.location.href
          });
        } else {
          navigator.clipboard.writeText(text).then(() => {
            this.showShareResult('Result copied to clipboard! 📋');
          }).catch(() => {
            this.showShareResult('Failed to copy result. Try again!', 'error');
          });
        }
      }

      showShareResult(message, type = 'success') {
        const shareResult = document.getElementById('share-result');
        shareResult.textContent = message;
        shareResult.style.display = 'block';
        
        // Update styling based on type
        shareResult.style.background = type === 'error' ? 'rgba(255, 0, 0, 0.1)' : 
                                      type === 'info' ? 'rgba(0, 100, 255, 0.1)' :
                                      'rgba(0, 255, 0, 0.1)';
        shareResult.style.color = type === 'error' ? '#ff6666' : 
                                 type === 'info' ? '#66aaff' :
                                 '#00ff88';
        shareResult.style.borderColor = type === 'error' ? 'rgba(255, 0, 0, 0.3)' : 
                                       type === 'info' ? 'rgba(0, 100, 255, 0.3)' :
                                       'rgba(0, 255, 0, 0.3)';
        
        setTimeout(() => {
          shareResult.style.display = 'none';
        }, 3000);
      }

      setupEventListeners() {
        // Connect Wallet button
        document.getElementById('connect-wallet').addEventListener('click', async () => {
          await connectWallet();
        });

        // New Game button - requires wallet connection
        document.getElementById('new-game').addEventListener('click', async () => {
          if (!walletConnected) {
            this.showShareResult('Please connect your wallet first! 🔗', 'error');
            return;
          }
          this.initializeGame();
        });

        // Mode toggle
        document.getElementById('toggle-mode').addEventListener('click', () => {
          if (!walletConnected) {
            this.showShareResult('Please connect your wallet first! 🔗', 'error');
            return;
          }
          this.toggleMode();
        });

        // Difficulty buttons
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            if (!walletConnected) {
              this.showShareResult('Please connect your wallet first! 🔗', 'error');
              return;
            }
            this.changeDifficulty(e.target.dataset.difficulty);
          });
        });

        // Sound toggle
        document.getElementById('sound-toggle').addEventListener('click', () => {
          this.soundEnabled = !this.soundEnabled;
          document.getElementById('sound-toggle').textContent = this.soundEnabled ? '🔊' : '🔇';
        });

        // Share buttons
        document.getElementById('share-warpcast').addEventListener('click', () => {
          this.shareToWarpcast();
        });

        document.getElementById('share-general').addEventListener('click', () => {
          this.copyGameLink();
        });

        // Early adopter mint button
        document.getElementById('mint-early-btn').addEventListener('click', async () => {
          await mintEarlyAdopter();
        });

        // Share/Mint result button
        document.getElementById('share-result-btn').addEventListener('click', async () => {
          if (this.gameState === 'ready' || this.gameState === 'playing') {
            this.showShareResult('Finish the game first! 🎮', 'error');
            return;
          }

          // Check if wallet is connected
          if (!walletConnected) {
            this.showShareResult('Please connect your wallet first! 🔗', 'error');
            return;
          }

          // Check if we're on Base chain
          try {
            const network = await provider.getNetwork();
            if (network.chainId !== 8453) {
              this.showShareResult('Please switch to Base chain to mint NFTs! 🔄', 'error');
              return;
            }
          } catch (err) {
            this.showShareResult('Unable to check network. Please ensure you\'re on Base chain.', 'error');
            return;
          }

          const doMint = confirm("Do you want to mint this game result as an NFT on Base chain? (Optional)\n\nClick OK to mint NFT\nClick Cancel to just share result");
          
          if (doMint) {
            const result = {
              difficulty: this.currentDifficulty,
              time: this.timer,
              win: this.gameState === 'won',
              farcasterUser: farcasterUser // Include Farcaster user data
            };
            await captureAndMint(result);
          } else {
            this.shareResult();
          }
        });
      }

      // Enable game after wallet connection
      enableGame() {
        document.querySelectorAll('.difficulty-btn, #new-game, #toggle-mode').forEach(el => {
          el.classList.remove('game-disabled');
        });
        document.getElementById('minefield').classList.remove('game-disabled');
      }

      // Disable game when wallet not connected
      disableGame() {
        document.querySelectorAll('.difficulty-btn, #new-game, #toggle-mode').forEach(el => {
          el.classList.add('game-disabled');
        });
        document.getElementById('minefield').classList.add('game-disabled');
      }
    }

    // Enhanced mobile detection
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
             window.innerWidth <= 768;
    }

    // Check if running in Farcaster mobile app
    function isFarcasterApp() {
      return window.farcasterSdk && 
             (window.location.href.includes('farcaster') || 
              navigator.userAgent.includes('Farcaster') ||
              window.farcasterSdk.context);
    }

    // Initialize game when page loads
    document.addEventListener('DOMContentLoaded', async () => {
      // Create game instance
      window.gameInstance = new Minesweeper();
      
      // Log environment info
      console.log("Environment:", {
        isMobile: isMobileDevice(),
        isFarcaster: isFarcasterApp(),
        userAgent: navigator.userAgent,
        availableProviders: detectWalletProviders().map(p => p.name)
      });
      
      // Initialize wallet UI
      await updateWalletUI();

      // Wait for Farcaster SDK to be ready
      if (window.farcasterSdk) {
        try {
          // Initialize Farcaster SDK
          await window.farcasterSdk.actions.ready();
          console.log("✅ Farcaster Mini App SDK ready");

          // Check if user is already authenticated in Farcaster
          const context = await window.farcasterSdk.context;
          if (context?.user) {
            console.log("Farcaster user context:", context.user);
            farcasterUser = context.user;
            
            // Show user info in game
            window.gameInstance.showShareResult(`👋 Welcome ${context.user.displayName || context.user.username || 'Farcaster User'}!`, "info");
            
            // Try to auto-connect wallet if in Farcaster app
            if (isFarcasterApp()) {
              console.log("Attempting auto-connect in Farcaster app...");
              setTimeout(async () => {
                try {
                  await connectWallet();
                } catch (err) {
                  console.log("Auto-connect failed:", err.message);
                }
              }, 1000);
            }
          }

        } catch (error) {
          console.error("Farcaster SDK initialization failed:", error);
        }
      } else {
        console.log("Farcaster SDK not available, running in fallback mode");
      }

      // Show initial connection prompt
      setTimeout(() => {
        if (!walletConnected) {
          const message = isFarcasterApp() ? 
            "Tap 'Connect Wallet' to start playing in Farcaster! 🎮" :
            "Click 'Connect Wallet' to start playing! 🎮";
          window.gameInstance.showShareResult(message, "info");
          window.gameInstance.disableGame();
        }
      }, 1500);

      // Try to show mint button/status if already connected
      if (walletConnected) {
        try { await refreshMintUI(); } catch (_) {}
      }

      // React to network/account changes to toggle mint button
      if (window.ethereum) {
        window.ethereum.on('chainChanged', async () => {
          await updateWalletUI();
          if (walletConnected) { try { await refreshMintUI(); } catch (_) {} }
        });
        window.ethereum.on('accountsChanged', async (accounts) => {
          if (accounts && accounts.length > 0) {
            userAddress = accounts[0];
            await updateWalletUI();
            if (walletConnected) { try { await refreshMintUI(); } catch (_) {} }
          }
        });
      }

      // Listen for WalletConnect events
      if (walletConnectProvider) {
        walletConnectProvider.on('accountsChanged', async (accounts) => {
          if (accounts && accounts.length > 0) {
            userAddress = accounts[0];
            await updateWalletUI();
            if (walletConnected) { try { await refreshMintUI(); } catch (_) {} }
          }
        });
        
        walletConnectProvider.on('chainChanged', async (chainId) => {
          await updateWalletUI();
          if (walletConnected) { try { await refreshMintUI(); } catch (_) {} }
        });
      }
    });
  </script>
</body>
</html>
